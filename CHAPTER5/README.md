# CHAPTER5 표현식과 연산자

결과를 명시적으로 반환하는 것이 **표현식** 이다.
표현식은 **값**이 된다. 그 결과를 다른 표현식에 결합해서 다른 값을 얻을 수 있다. 그 값을 또 다른 표현식에 결합해서 또 다른 값을 얻는 식으로 이어질 수 있다. 표현식이 아닌 문은 이런식으로 결합할 수 없다. 

**표현식은 값이 되므로 할당에 쓸 수 있다.**
즉 표현식의 결과를 변수나 상수, 프로퍼티에 할당할 수 있다.

```c
let x;
x = 3 * 5; // 곱셈표현식 3*5 = 15, 할당표현식 x = 3*5 
```

표현식은 대부분 연산자표현식이다.
값이 되는 것은 모두 표현식이므로, **변수와 상수, 리터럴**도 모두 표현식이다.

## 5.1 연산자

표현식이 값이 되는 것 이라면 연산자는 **값을 만드는 행동** 이다.
> **Tip:** 연산자는 하나 이상의 피연산자가 있어야 결과를 낼 수 있다. ex) 1 + 2

## 5.2 산술연산자

 - 단항플러스 (+X //X가 숫자가 아니면 숫자로 변환을 시도)
```c
	const s;
	const y = 3 + +s; 
	// y는 8, 단항플러스(+)를 사용하지 않았다면, 
	// 문자열 병합으로 인해 값이 "35"가 된다.
```
- 단항부정 (-X //X의 부호를 바꾼다. X가 5이면 -X는 -5이다.)
```c
	const x = 5;
	const y = 3 - -x;  // y는 8
```
- 전위증가, 전위감소 ( ++X, --X //X에서 1을 더하거나 뺀 다음 평가한다.)
- 후위증가, 후위감소 ( ++X, --X //X의 값을 평가한 다음 1을 더하거나 빼준다.)
```c
	let x = 2;
	const r1 = x++ + x++; // 결과 2 + 3 = 5, x = 4
	const r2 = ++x + ++x; // 결과 5 + 6 = 11, x = 6
```
```c
	let y = 10;
	const r3 = y-- + y--; // 결과 10 + 9 = 19, y = 8
	const r4 = --y + --y; // 결과 7 + 6 = 13, y = 6
```
> **Tip:** 증가와 감소 연산자는 덧셈보다 먼저 실행된다.

## 5.3 연산자 우선순위
연산자의 우선순위가 높을수록 먼저 실행된다.
우선순위가 같은 연산자들은 오른쪽에서 왼쪽으로 또는 왼쪽에서 오른쪽으로 평가한다.

## 5.4 비교연산자
비교연산자는  `일치함(===), 동등함(==), 대소관계` 의 세 가지 타입으로 나뉜다.
 
 - 일치함 
	 - 두 값이 같은 객체를 가리키거나, 같은 타입이고 값도 같다면 값이 일치한다고 함
	 - `두 값이 일치할 경우 (===), 그 반대인 경우 (!==)`
	 - 
  - 동등함
	 - 두 값이 같은 객체를 가리키거나 같은 값을 갖도록 변환할 수 있다면 동등하다고 함
	 - 문자열 "33"은 숫자 33으로 **변환할 수 있으므로 동등**하지만, 
	    **타입이 다르므로 일치하지 않는다.**
     - `두 값이 동등할 경우 (==), 그 반대인 경우 (!=)`
 
```c
	const n = 5;
	const s = "5";
	
	n === s; // false
	n !== s; // true
	n == s; // true
	n != s; // false

	const a = {name: "an object"};
	const b = {name: "an object"};

	a === b; // false , 객체는 항상 다르다.
```

## 5.5 숫자비교
> **caution:**
특별한 숫자형 값 NaN	은 그 자신을 포함하여 무엇과도 같지 않다.
즉 NaN === Nan , Nan == NaN은 모두 false이다.

## 5.6 문자열 병합
```c
 3 + 5 + "8" 
 // 문자열 "88"이 된다.
 // 3 + 5 를 덧셈으로 판단 , 8 + "8" 을 문자열 병합으로 판단
 
 "3" + 5 + 8 
 // 문자열 "358"이 된다.
 // "3" + 5 를 병합으로 판단, "35" + 8 또한 병합으로 판단
```

## 5.7 논리연산자

### 참 같은 값과 거짓 같은 값
자바스크립트에서는 모든 데이터 타입을 참 같은 값과 거짓 같은 값으로 나눌 수 있다.

**거짓같은 값**

 - undefined
 - null
 - false
 - 0
 - NaN
 - ' ' (빈 문자열)
 
 **참 같은 값**
 
 - 모든 객체, value() 메서드를 호출했을 때 false를 반환하는 객체도 참 같은 값에 속한다.
 - 배열, 빈 배열도 참 같은 값에 속한다.
 - 공백만 있는 문자열 (" " 등)
 - 문자열 "false"

## 5.8 AND, OR, NOT
자바스크립트가 지원하는 논리 연산자는 AND(&&) , OR (||) , NOT (!) 세가지 이다.

AND(&&)
X : false, Y : false 일 경우 X && Y : false
X : true, Y : true 일 경우 X && Y : true

OR(||)
X : false, Y : false 일 경우 X && Y : false
X : false, Y : true 일 경우 X && Y : true
X : true, Y : true 일 경우 X && Y : true

NOT(!)
X : false, !X : true
X : true, !X: false

> **Note**
> AND : 피연산자가 모두 true일 때만 true
> OR : 피연산자가 모두 false일 때만 false
> NOT : 단순히 피연산자를 반대로 바꾼다.

배타적 OR 또는 XOR 이라 불리는 OR 도 있다. 이 연산자는 피연산자가 모두 true이면
false를 반환된다. 하지만 자바스크립트에는 XOR에 해당하는 논리 연산자가 없다.
>**Tip** : 변수 x와 y의 XOR	연산이 필요하다면 동등한 표현식 
>( x || y ) && x !== y 를 사용하면 된다.

### 5.8.1 단축평가
자바스크립트에서는 단축평가가 일어납니다. x의 값이 false라면 x && y의 값은 y에 상관없이 false를 가지게 된다.
이처럼 **두 값을 모두 평가하지 않아도 될 때에 단축평가가 일어난다.**

```c
const foo = true; // 첫번째 피연산자
let bar = 0;
const result = foo || bar++; // 단축평가가 일어남
// 세번째 행에서 단축평가가 일어나므로, result값은 true가 된다.
```
>**Note**
>단축평가가 일어나면 확인할 필요가 없는 피연산자에 부수효과가 있더라도 효과가 발생하지 않는다.
>foo의 값이 false면 bar의 값에 따라 true인지 false인지를 결정할 수 있기 때문에 값을 평가해야한다. 그러면 result에는 0이라는 값이 담기고, bar의 값이 1 증가한다.

### 5.8.2 피연산자가 불리언이 아닐 때 논리 연산자가 동작하는 방법
```c
 const options = suppliedOptions || {name: "Defult"}
```
객체는 항상 참 같은 값으로 평가된다. 따라서 suppliedOptions가 객체이면 
options는 suppliedOptions를 가리키게 된다.
옵션이 제공되지 않으면, 즉 suppliedOptions가 null 이나 undefined라면 	options는
기본값을 갖게된다.

>**Tip** : NOT은 불리언 아닌 값을 반환할 수 없으므로 ! 연산자는 피 연산자의 타입이
>무엇이든 항상 불리언을 반환한다.
>피연산자가 참같은 값이면 false, 거짓같은 값이면 true 반환

### 5.8.3 조건연산자
자바스크립트의 유일한 3항 연산자이다.
3항연산자는 문이 아니라 표현식이므로 다른 표현식과 결합하여 사용할 수 있다.
```c
const foo = false;
const result = doIt? "Did it!" : "Didn't do it";
// 물음표 앞에 있는 첫번째 피연산자가 참 같은 값이면, "Did it!"
// 물음표 앞에 있는 첫번째 피연산자가 거짓 같은 값이면, "Didn't do it"
```

### 5.8.3 쉼표연산자
쉼표연산자는 표현식을 결합하여 두 표현식을 평가한 후, 두번째 표현식의 결과를 반환한다.
```c
let x = 0, y = 10, z;
z = (x++, y++)
// x 와 y는 모두 1만큼 늘어났지만, z의 값은 10이다. 이 값은 y++ 가 반환한 값이다.
// 쉼표연산자는 우선순위가 가장 낮은 연산자이므로 괄호를 사용.
```


